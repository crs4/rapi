

/* Java SWIG interface for rapi.h */

%module Rapi

/*
Remove rapi_ prefix from all function and structure names.
Make sure this general rename comes before the ignore clauses below
or they won't have effect.
*/
%rename("NO_ERROR")               "RAPI_NO_ERROR";
%rename("GENERIC_ERROR")          "RAPI_GENERIC_ERROR";
%rename("OP_NOT_SUPPORTED_ERROR") "RAPI_OP_NOT_SUPPORTED_ERROR";
%rename("MEMORY_ERROR")           "RAPI_MEMORY_ERROR";
%rename("PARAM_ERROR")            "RAPI_PARAM_ERROR";
%rename("TYPE_ERROR")             "RAPI_TYPE_ERROR";


%rename("%(strip:[rapi_])s") ""; // e.g., rapi_load_ref -> load_ref


// ignore functions from klib
%rename("$ignore", regextarget=1) "^k";
%rename("$ignore", regextarget=1) "^K";

// also ignore anything that starts with an underscore
%rename("$ignore", regextarget=1) "^_";

// Swig doesn't support applying multiple renaming rules to the same identifier.
// To get camel case, we'll need to rename the wrapped classes individually.
// %rename("%(camelcase)s", %$isclass) "";

// First we need to include the helpers, since they're used throughput
// the wrapping code
%include "../rapi_swig_helpers.i"

%header %{
#define FQ_EXCEPTION_NAME(name) "it/crs4/rapi/lowrapi/" #name

const char* rapi_err_to_except(rapi_error_t error_code)
{
  switch (error_code) {
    case RAPI_OP_NOT_SUPPORTED_ERROR:
      return FQ_EXCEPTION_NAME(RapiOpNotSupportedException);

    case RAPI_MEMORY_ERROR:
      return FQ_EXCEPTION_NAME(RapiOutOfMemoryError);

    case RAPI_PARAM_ERROR:
      return FQ_EXCEPTION_NAME(RapiInvalidParamException);

    case RAPI_TYPE_ERROR:
      return FQ_EXCEPTION_NAME(RapiInvalidTypeException);

    default:
    case RAPI_GENERIC_ERROR:
      return FQ_EXCEPTION_NAME(RapiException);
  }
}

void do_rapi_throw(JNIEnv *jenv, rapi_error_t err_code, const char* msg)
{
    const char* ex_name = rapi_err_to_except(err_code);
    jclass clazz = (*jenv)->FindClass(jenv, ex_name);
    if (clazz) {
      (*jenv)->ThrowNew(jenv, clazz, msg);
    }
    else {
      char new_msg[1024];
      snprintf(new_msg, sizeof(new_msg), "BUG! Tried to throw %s but failed to find the exception class", ex_name);
      clazz = (*jenv)->FindClass(jenv, "java/lang/RuntimeException");
      (*jenv)->ThrowNew(jenv, clazz, new_msg);
    }
}

%}


/* Eliminate the rapi_error_t return value from all functions, turning
   it into a 'void'.  Later we'll have to add error checking code to
   throw a Java exception then an error is generated by the wrapped C function.
*/
%typemap(out) rapi_error_t ""

%typemap(jstype) rapi_error_t "$typemap(jstype,void)"
%typemap(jtype) rapi_error_t "$typemap(jtype,void)"
%typemap(jni) rapi_error_t "$typemap(jni,void)";
%typemap(javaout) rapi_error_t "$typemap(javaout,void)";


// This macro inserts error checking code (to raise a Java exception)
%define CHECK_RAPI_ERROR(msg)
  if (result != RAPI_NO_ERROR) {
    do_rapi_throw(jenv, result, msg);
    return $null;
  }
%enddef

// This macro inserts error checking code (to raise a Java exception) AND
// adds the 'throws' clause.  The clause will indicate a RapiException, though
// the function may also throw any of the exceptions derived from RapiException.
%define Set_exception_from_error_t(fn_name)
%javaexception("RapiException") fn_name {
  $action
  CHECK_RAPI_ERROR("")
}
%enddef



/**************************************************
 ###  Typemaps
 **************************************************/

/*
rapi_error_t is the error type for the RAPI library.
*/
typedef int rapi_error_t;
typedef long long rapi_ssize_t;

%typemap(jtype) uint8_t jshort;


%inline %{
typedef int rapi_bool;
%}

%typemap(jtype) rapi_bool "boolean";
%typemap(jstype) rapi_bool "boolean";
%typemap(jni) rapi_bool "jboolean";

// set a default exception handler for all funcition

%mutable;

/**************************************************
 ###  Include rapi_common.i
 * Include it after we've defined all renaming rules, features,
 * typemaps, etc.
 **************************************************/
%include "../rapi_common.i"
/**************************************************
 **************************************************/


%immutable;

/************ begin wrapping functions and structures **************/

%mutable;
/********* rapi_opts *******/
typedef struct rapi_opts {
  int ignore_unsupported;
  /* Standard Ones - Differently implemented by aligners*/
  int mapq_min;
  int isize_min;
  int isize_max;
  int n_threads;
  rapi_bool share_ref_mem;

  /* Mismatch / Gap_Opens / Quality Trims --> Generalize ? */

  // TODO: how to wrap this thing?
  //kvec_t(rapi_param) parameters;
} rapi_opts;


///* Init and tear down library */
Set_exception_from_error_t(rapi_init)
rapi_error_t rapi_init(const rapi_opts* opts);

Set_exception_from_error_t(rapi_shutdown)
rapi_error_t rapi_shutdown(void);


/****** IMMUTABLE *******/
// Everything from here down is read-only

%immutable;

/*
The char* returned by the following functions are wrapped automatically by
SWIG -- the wrapper doesn't try to free the strings since they are "const".
*/
const char* rapi_aligner_name(void);
const char* rapi_aligner_version(void);
const char* rapi_plugin_version(void);

/***************************************
 ****** rapi_contig and rapi_ref *******
 ***************************************/


typedef struct rapi_contig {
  char * name;
  uint32_t len;
  char * assembly_identifier;
  char * species;
  char * uri;
  char * md5;
} rapi_contig;


typedef struct rapi_ref {
  char * path;
  int n_contigs;
} rapi_ref;


/* Load reference */
Set_exception_from_error_t(rapi_ref_load)
rapi_error_t rapi_ref_load( const char * reference_path, rapi_ref * ref_struct );

/* Free reference */
Set_exception_from_error_t(rapi_ref_free)
rapi_error_t rapi_ref_free( rapi_ref * ref_struct );


/***************************************/
/*      Alignments                     */
/***************************************/

%nodefaultctor rapi_alignment;

typedef struct rapi_alignment {
  rapi_contig* contig;
  unsigned long int pos; // 1-based
  short mapq;
  int score; // aligner-specific score

  short n_mismatches;
  short n_gap_opens;
  short n_gap_extensions;
} rapi_alignment;

%newobject rapi_alignment::get_cigar_string;
%extend rapi_alignment {

    // synthesize boolean attributes corresponding to bitfield values
    rapi_bool paired;
    rapi_bool prop_paired;
    rapi_bool mapped;
    rapi_bool reverse_strand;
    rapi_bool secondary_aln;

/*
    rapi_cigar_ops get_cigar_ops() const {
        rapi_cigar_ops array;
        array.ops = $self->cigar_ops;
        array.len = $self->n_cigar_ops;
        return array;
    }
*/
    char* get_cigar_string() const {
        kstring_t output = { 0, 0, NULL };
        rapi_put_cigar($self->n_cigar_ops, $self->cigar_ops, 0, &output);
        // return the string directly. Wrapper will be responsible for freeing it (through %newobject)
        return output.s;
    }
/*
    rapi_tag_list get_tags() const {
        return $self->tags;
    }
*/
    int get_rlen() const {
      return rapi_get_rlen($self->n_cigar_ops, $self->cigar_ops);
    }
};


%{
rapi_bool rapi_alignment_paired_get(const rapi_alignment* aln) {
    return aln->paired != 0;
}

rapi_bool rapi_alignment_prop_paired_get(const rapi_alignment* aln) {
    return aln->prop_paired != 0;
}

rapi_bool rapi_alignment_mapped_get(const rapi_alignment* aln) {
    return aln->mapped != 0;
}

rapi_bool rapi_alignment_reverse_strand_get(const rapi_alignment* aln) {
    return aln->reverse_strand != 0;
}

rapi_bool rapi_alignment_secondary_aln_get(const rapi_alignment* aln) {
    return aln->secondary_aln != 0;
}
%}



/***************************************/
/*      Reads and read batches         */
/***************************************/
typedef struct rapi_read {
  char * id;
  char * seq;
  char * qual;
  unsigned int length;
} rapi_read;


typedef struct rapi_batch {
  rapi_ssize_t n_frags;
  int n_reads_frag;
} rapi_batch;

/* Allocate and load reads */
Set_exception_from_error_t(rapi_reads_alloc)
rapi_error_t rapi_reads_alloc( rapi_batch * batch, int n_reads_fragment, int n_fragments );

Set_exception_from_error_t(rapi_reads_reserve)
rapi_error_t rapi_reads_reserve(rapi_batch* batch, rapi_ssize_t n_fragments);

Set_exception_from_error_t(rapi_reads_clear)
rapi_error_t rapi_reads_clear(rapi_batch* batch);

Set_exception_from_error_t(rapi_reads_free)
rapi_error_t rapi_reads_free(rapi_batch * batch);

rapi_ssize_t rapi_batch_read_capacity(const rapi_batch* batch);

Set_exception_from_error_t(rapi_set_read)
rapi_error_t rapi_set_read(rapi_batch * batch, rapi_ssize_t n_frag, int n_read, const char* id, const char* seq, const char* qual, int q_offset);

rapi_read* rapi_get_read(const rapi_batch* batch, rapi_ssize_t n_frag, int n_read);

/***************************************/
/*      The aligner                    */
/***************************************/

%nodefaultctor  rapi_aligner_state;
%nodefaultdtor  rapi_aligner_state;
typedef struct rapi_aligner_state {} rapi_aligner_state; //< opaque structure.  Aligner can use for whatever it wants.

// Typemap settings to return the new aligner state as a return value.
// See http://stackoverflow.com/questions/12739331/swig-interface-to-receive-an-opaque-struct-reference-in-java-through-function-ar
// For an explanation.
%typemap(in, numinputs=0) rapi_aligner_state** ret_state (rapi_aligner_state *tmp_ptr) {
  $1 = &tmp_ptr;
}

%typemap(jstype) rapi_error_t rapi_aligner_state_init "$typemap(jstype,rapi_aligner_state*)"
%typemap(jtype) rapi_error_t rapi_aligner_state_init "$typemap(jtype,rapi_aligner_state*)"
%typemap(jni) rapi_error_t rapi_aligner_state_init "$typemap(jni,rapi_aligner_state*)";
%typemap(javaout) rapi_error_t rapi_aligner_state_init "$typemap(javaout,rapi_aligner_state*)";

%typemap(out) rapi_error_t rapi_aligner_state_init ""
%typemap(argout) rapi_aligner_state ** {
  *(rapi_aligner_state **)&$result = *$1;
}

Set_exception_from_error_t(rapi_aligner_state_init)
rapi_error_t rapi_aligner_state_init(rapi_aligner_state** ret_state, const rapi_opts* opts);


Set_exception_from_error_t(rapi_align_reads);
rapi_error_t rapi_align_reads( const rapi_ref* ref, rapi_batch* batch,
    rapi_ssize_t start_frag, rapi_ssize_t end_frag, rapi_aligner_state* state );

Set_exception_from_error_t(rapi_aligner_state_free);
rapi_error_t rapi_aligner_state_free(rapi_aligner_state* state);

/***************************************/
/*      SAM output                     */
/***************************************/

// With this typemap we can create wrapper functions that receive the JNIEnv* as an argument,
// but hiding it from the Java-side API.
%typemap(in, numinputs=0) JNIEnv* jenv { $1 = jenv; }


%newobject format_sam_hdr;
%inline %{
char* format_sam_hdr(JNIEnv* jenv, const rapi_ref* ref)
{
  kstring_t output = { 0, 0, NULL };
  rapi_error_t error = rapi_format_sam_hdr(ref, &output);
  if (error == RAPI_NO_ERROR) {
    return output.s;
  }
  else {
    do_rapi_throw(jenv, error, "Failed to format SAM header");
    return NULL;
  }
}
%}


%newobject format_sam_batch;
%inline %{
char* format_sam_batch(JNIEnv* jenv, const rapi_batch* reads)
{
  if (!reads) {
    do_rapi_throw(jenv, RAPI_PARAM_ERROR, "NULL read_batch pointer!");
    return NULL;
  }

  kstring_t output = { 0, 0, NULL };
  rapi_error_t error = RAPI_NO_ERROR;

  for (rapi_ssize_t i = 0; i < reads->n_frags && error == RAPI_NO_ERROR; ++i) {
    error = rapi_format_sam_b(reads, i, &output);
    kputc('\n', &output);
  }
  if (error == RAPI_NO_ERROR) {
    return output.s;
  }
  else {
    free(output.s);
    do_rapi_throw(jenv, error, "Failed to format SAM");
    return NULL;
  }
}
%}


/**************************************************
 ###  Object extensions
 **************************************************/

/***************************************
 ****** other stuff              *******
 ***************************************/
